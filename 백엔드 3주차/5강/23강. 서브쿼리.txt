##23강. 서브쿼리

#예제 5-16. sample51 테이블
#예제 5-15. sample54에서 a의 최솟값 검색하기
mysql> SELECT * FROM sample54;
+------+------+
| no   | a    |
+------+------+
|    1 |  100 |
|    2 |  900 |
|    3 |   20 |
|    4 |   80 |
+------+------+
4 rows in set (0.462 sec)

mysql> SELECT MIN(a) FROM sample54;
+--------+
| MIN(a) |
+--------+
|     20 |
+--------+
1 row in set (0.015 sec)

#예제 5-18. 최솟값을 가지는 행 삭제하기
#MySQL에서는 오류 발생. 데이터를 추가하거나 갱신할 경우
#동일한 테이블을 서브쿼리에서 사용할 수 없기 때문
#인라인 뷰로 임시 테이블 만들어야 함.

mysql> DELETE FROM sample54 WHERE a = (SELECT MIN(a) FROM sample54);
ERROR 1093 (HY000): You can't specify target table 'sample54' for update in FROM clause

mysql> DELETE FROM sample54 WHERE a = (SELECT a FROM(SELECT MIN(a) AS a FROM sample54) AS x);
Query OK, 1 row affected (0.163 sec)

mysql> SELECT * FROM sample54;
+------+------+
| no   | a    |
+------+------+
|    1 |  100 |
|    2 |  900 |
|    4 |   80 |
+------+------+
3 rows in set (0.012 sec)

#예제 5-19. 서브쿼리의 패턴
#하나의 값을 반환하는 패턴
mysql> SELECT MIN(a) FROM sample54;
+--------+
| MIN(a) |
+--------+
|     80 |
+--------+
1 row in set (0.016 sec)

#복수의 행이 반한되지만 열은 하나인 패턴
mysql> SELECT no FROM sample54;
+------+
| no   |
+------+
|    1 |
|    2 |
|    4 |
+------+
3 rows in set (0.012 sec)

#하나의 행이 반환되지만 열이 복수인 패턴
mysql> SELECT MIN(a), MAX(no) FROM sample54;
+--------+---------+
| MIN(a) | MAX(no) |
+--------+---------+
|     80 |       4 |
+--------+---------+
1 row in set (0.021 sec)

#복수의 행, 복수의 열이 반환되는 패턴
mysql> SELECT no, a FROM sample54;
+------+------+
| no   | a    |
+------+------+
|    1 |  100 |
|    2 |  900 |
|    4 |   80 |
+------+------+
3 rows in set (0.013 sec)

#예제 5-20. SELECT 구에서 서브쿼리 사용하기
SELECT
 (SELECT COUNT(*) FROM sample51) AS sq1,
 (SELECT COUNT(*) FROM sample54) AS sq2;
+------+------+
| sq1  | sq2  |
+------+------+
|    5 |    3 |
+------+------+
1 row in set (0.118 sec)

#Oracle에서는 FROM 구를 생략할 수 없으므로 FROM DUAL로 지정해야 함
SELECT
 (SELECT COUNT(*) FROM sample51) AS sq1,
 (SELECT COUNT(*) FROM sample54) AS sq2 FROM DUAL;

#예제 5-22. SET 구에서 서브쿼리 사용하기
#책에 있는 대로 기술하였는데 왜 오류가?
UPDATE sample54
SET a = (
  SELECT max_a
  FROM (SELECT MAX(a) AS max_a FROM sample54) AS t
);
Query OK, 2 rows affected (0.169 sec)
Rows matched: 3  Changed: 2  Warnings: 0
#예제 5-18과 같은 문제.
#같은 테이블을 UPDATE와 SELECT에 동시 지정 안 됨
#서브쿼리를 한 번 더 감싸준다.
mysql> SELECT * FROM sample54;
+------+------+
| no   | a    |
+------+------+
|    1 |  900 |
|    2 |  900 |
|    4 |  900 |
+------+------+
3 rows in set (0.012 sec)

#예제 5-23. FROM 구에서 서브쿼리 사용하기
#예제 5-24. FROM 구에서 서브쿼리 사용하기(AS로 지정) → Oracle에서는 안 붙임
#예제 5-25. FROM 구에서 서브쿼리 사용하기(3단계)
mysql> SELECT * FROM (SELECT * FROM sample54) sq;
+------+------+
| no   | a    |
+------+------+
|    1 |  900 |
|    2 |  900 |
|    4 |  900 |
+------+------+
3 rows in set (0.017 sec)

mysql> SELECT * FROM (SELECT * FROM sample54) AS sq;
+------+------+
| no   | a    |
+------+------+
|    1 |  900 |
|    2 |  900 |
|    4 |  900 |
+------+------+
3 rows in set (0.013 sec)

mysql> SELECT * FROM (SELECT * FROM (SELECT * FROM sample54) sq1) sq2;
+------+------+
| no   | a    |
+------+------+
|    1 |  900 |
|    2 |  900 |
|    4 |  900 |
+------+------+
3 rows in set (0.017 sec)
#물론 테이블 한 개를 지정하는 데 3단계 중첩까지는...

#예제 5-27. VALUES 구에서 서브쿼리 사용하기
mysql> INSERT INTO sample541 VALUES (
    -> (SELECT COUNT(*) FROM sample51),
    -> (SELECT COUNT(*) FROM sample54)
    -> );
Query OK, 1 row affected (0.485 sec)

mysql> SELECT * FROM sample541;
+------+------+
| a    | b    |
+------+------+
|    5 |    3 |
+------+------+
1 row in set (0.013 sec)

#예제 5-28. SELECT 결과를 INSERT하기
mysql> INSERT INTO sample541 SELECT 1, 2;
#SELECT는 다른 테이블에서 읽어와 삽입할 때 주로 사용
Query OK, 1 row affected (0.153 sec)
Records: 1  Duplicates: 0  Warnings: 0

mysql> SELECT * FROM sample541;
+------+------+
| a    | b    |
+------+------+
|    5 |    3 |
|    1 |    2 |
+------+------+
2 rows in set (0.011 sec)
#INSERT INTO sample541 VALUES (1, 2)의 경우와 같음

#열 구성이 똑같은 테이블 사이에는 다음과 같은 INSERT SELECT 명령으로 행을 복사할 수도 있음.
INSERT INTO sample542 SELECT * FROM sample543;
